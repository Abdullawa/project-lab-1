#include <msp430fr6989.h>
#include <stdint.h>

/* ============================================================
   Motor Control (your original working motor code)
   ============================================================ */
#define ENA_BIT   BIT7      // P2.7 -> ENA
#define ENB_BIT   BIT6      // P2.6 -> ENB
#define IN1_BIT   BIT3      // P1.3 -> IN1 (Left dir A)
#define IN2_BIT   BIT0      // P3.0 -> IN2 (Left dir B)
#define IN3_BIT   BIT1      // P3.1 -> IN3 (Right dir A)
#define IN4_BIT   BIT3      // P2.3 -> IN4 (Right dir B)
#define LED_BIT   BIT0      // P1.0 debug LED

#define SMCLK_HZ     1000000UL
#define PWM_FREQ_HZ  20000UL
#define PWM_PERIOD   (SMCLK_HZ / PWM_FREQ_HZ)

#define MOVE_1FT_MS   1100
#define TURN_90_MS     500
#define FWD_DUTY_PCT    55
#define TURN_DUTY_PCT   60

volatile unsigned int dutyA = (PWM_PERIOD * FWD_DUTY_PCT) / 100;
volatile unsigned int dutyB = (PWM_PERIOD * FWD_DUTY_PCT) / 100;
volatile unsigned int pwmSub = 0;
volatile unsigned long ms_ticks = 0;
volatile unsigned char sleep_flag = 0;

/* ===== IR Receiver config ===== */
#define IR_PIN          BIT1        // P2.1 input (TSOP active-low)
#define DBG_OUT         BIT4        // P9.4 debug out
#define SHORT_MARK_US   4000
#define LONG_MARK_US    9000
#define FRAME_GAP_US   80000

volatile uint16_t last_time = 0;
volatile uint32_t pulse_width = 0;
volatile uint8_t  bit_index = 0;
volatile uint8_t  nibble = 0;
volatile uint8_t  frame_ready = 0;

/* ===== Prototypes ===== */
static void clock_init(void);
static void gpio_init(void);
static void timers_init(void);
static void sleep_ms(unsigned long ms);
static void set_duty_pct(unsigned pctA, unsigned pctB);
static void soft_start(unsigned pctA, unsigned pctB, unsigned ramp_ms);
static void set_forward(void);
static void set_reverse(void);
static void set_turn_right(void);
static void set_turn_left(void);
static void stop_motors(void);
static void hard_brake_ms(unsigned ms);

/* ============================================================
   Interrupts
   ============================================================ */
/* ---- PWM @ 20 kHz ---- */
#pragma vector=TIMER0_A0_VECTOR
__interrupt void TA0_ISR(void)
{
    pwmSub++;
    if (pwmSub >= PWM_PERIOD) pwmSub = 0;
    if (pwmSub < dutyA) P2OUT |= ENA_BIT; else P2OUT &= ~ENA_BIT;
    if (pwmSub < dutyB) P2OUT |= ENB_BIT; else P2OUT &= ~ENB_BIT;
}

/* ---- 1 ms tick ---- */
#pragma vector=TIMER0_B0_VECTOR
__interrupt void TB0_ISR(void)
{
    ms_ticks++;
    sleep_flag = 1;
    __bic_SR_register_on_exit(LPM0_bits);
}

/* ============================================================
   Hardware setup
   ============================================================ */
static void clock_init(void)
{
    WDTCTL = WDTPW | WDTHOLD;
    CSCTL0_H = CSKEY_H;
    CSCTL1   = DCOFSEL_5;                   // ~8 MHz
    CSCTL2   = SELS__DCOCLK | SELM__DCOCLK;
    CSCTL3   = DIVS__8 | DIVM__1;           // SMCLK = 1 MHz
    CSCTL0_H = 0;
}

static void gpio_init(void)
{
    PM5CTL0 &= ~LOCKLPM5;

    // --- Motor pins ---
    P2DIR |= ENA_BIT | ENB_BIT;  P2OUT &= ~(ENA_BIT | ENB_BIT);
    P1DIR |= IN1_BIT | LED_BIT;  P1OUT &= ~(IN1_BIT | LED_BIT);
    P3DIR |= IN2_BIT | IN3_BIT;  P3OUT &= ~(IN2_BIT | IN3_BIT);
    P2DIR |= IN4_BIT;            P2OUT &= ~IN4_BIT;

    // --- IR receiver input ---
    P2DIR  &= ~IR_PIN;
    P2REN  |=  IR_PIN;
    P2OUT  |=  IR_PIN;            // Pull-up, idle high
    P2IES  |=  IR_PIN;            // falling first
    P2IFG  &= ~IR_PIN;
    P2IE   |=  IR_PIN;

    // --- Debug output ---
    P9DIR |= DBG_OUT;
    P9OUT &= ~DBG_OUT;
}

static void timers_init(void)
{
    // TA0: 20 kHz PWM
    TA0CCR0  = PWM_PERIOD - 1;
    TA0CCTL0 = CCIE;
    TA0CTL   = TASSEL__SMCLK | MC__UP | TACLR;

    // TB0: 1 kHz ms tick
    TB0CCR0  = (SMCLK_HZ / 1000U) - 1;
    TB0CCTL0 = CCIE;
    TB0CTL   = TBSSEL__SMCLK | MC__UP | TBCLR;
}

/* ============================================================
   Utility + Motor helpers
   ============================================================ */
static void sleep_ms(unsigned long ms)
{
    unsigned long target = ms_ticks + ms;
    while ((long)(target - ms_ticks) > 0)
        __bis_SR_register(LPM0_bits | GIE);
}

static void set_duty_pct(unsigned pctA, unsigned pctB)
{
    if (pctA > 100) pctA = 100;
    if (pctB > 100) pctB = 100;
    dutyA = (PWM_PERIOD * pctA) / 100;
    dutyB = (PWM_PERIOD * pctB) / 100;
}

static void soft_start(unsigned pctA, unsigned pctB, unsigned ramp_ms)
{
    unsigned i, steps = 10, a, b;
    for (i = 0; i <= steps; i++) {
        a = (pctA * i) / steps;
        b = (pctB * i) / steps;
        set_duty_pct(a, b);
        sleep_ms(ramp_ms / steps);
    }
}

static void set_forward(void)
{
    P1OUT |= IN1_BIT;    P3OUT &= ~IN2_BIT;
    P3OUT |= IN3_BIT;    P2OUT &= ~IN4_BIT;
}
static void set_reverse(void)
{
    P1OUT &= ~IN1_BIT;   P3OUT |= IN2_BIT;
    P3OUT &= ~IN3_BIT;   P2OUT |= IN4_BIT;
}
static void set_turn_right(void)
{
    P1OUT |= IN1_BIT;    P3OUT &= ~IN2_BIT;
    P3OUT &= ~IN3_BIT;   P2OUT |= IN4_BIT;
}
static void set_turn_left(void)
{
    P1OUT &= ~IN1_BIT;   P3OUT |= IN2_BIT;
    P3OUT |= IN3_BIT;    P2OUT &= ~IN4_BIT;
}
static void stop_motors(void)
{
    P1OUT &= ~IN1_BIT;
    P3OUT &= ~(IN2_BIT | IN3_BIT);
    P2OUT &= ~IN4_BIT;
    set_duty_pct(0,0);
}
static void hard_brake_ms(unsigned ms)
{
    P1OUT |= IN1_BIT; P3OUT |= IN2_BIT;
    P3OUT |= IN3_BIT; P2OUT |= IN4_BIT;
    set_duty_pct(100,100);
    sleep_ms(ms);
    stop_motors();
}

/* ============================================================
   IR decoding  (this is your original working receiver logic)
   ============================================================ */
static void process_pulse(uint32_t width)
{
    if (width > FRAME_GAP_US) { bit_index = 0; nibble = 0; return; }

    nibble <<= 1;
    if (width < (SHORT_MARK_US + LONG_MARK_US)/2) nibble |= 0;
    else nibble |= 1;

    // Short pulse on P9.4 for each decoded bit
    P9OUT |= DBG_OUT; __delay_cycles(800); P9OUT &= ~DBG_OUT;

    bit_index++;
    if (bit_index >= 4) { frame_ready = 1; bit_index = 0; }
}

/* ---- ISR: rising/falling edges on P2.1 ---- */
#pragma vector=PORT2_VECTOR
__interrupt void PORT2_ISR(void)
{
    uint16_t now = TB0R;                 // Timer B0 counts @ 1 Âµs
    uint16_t delta = now - last_time;
    last_time = now;

    if ((P2IN & IR_PIN) != 0) process_pulse(delta);
    P2IES ^= IR_PIN;
    P2IFG &= ~IR_PIN;
}

/* ============================================================
   Main
   ============================================================ */
int main(void)
{
    clock_init();
    gpio_init();
    timers_init();
    set_duty_pct(0,0);
    __enable_interrupt();

    while (1)
    {
        if (frame_ready)
        {
            frame_ready = 0;

            // Long debug pulse = full frame decoded
            P9OUT |= DBG_OUT; __delay_cycles(8000); P9OUT &= ~DBG_OUT;

            switch (nibble)
            {
                case 0x1:   // Forward
                    set_forward();
                    soft_start(FWD_DUTY_PCT,FWD_DUTY_PCT,200);
                    sleep_ms(MOVE_1FT_MS);
                    hard_brake_ms(150);
                    stop_motors();
                    break;

                case 0x3:   // Turn right
                    set_turn_right();
                    soft_start(TURN_DUTY_PCT,TURN_DUTY_PCT,200);
                    sleep_ms(TURN_90_MS);
                    hard_brake_ms(150);
                    stop_motors();
                    break;

                case 0x5:   // Turn left
                    set_turn_left();
                    soft_start(TURN_DUTY_PCT,TURN_DUTY_PCT,200);
                    sleep_ms(TURN_90_MS);
                    hard_brake_ms(150);
                    stop_motors();
                    break;

                case 0x7:   // Reverse
                    set_reverse();
                    soft_start(FWD_DUTY_PCT,FWD_DUTY_PCT,200);
                    sleep_ms(MOVE_1FT_MS);
                    hard_brake_ms(150);
                    stop_motors();
                    break;

                case 0x9:   // Stop
                    hard_brake_ms(150);
                    stop_motors();
                    break;

                default:
                    break;
            }
        }
        __no_operation();
    }
}
